<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_162) on Sun Oct 14 12:03:49 UTC 2018 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Deprecated List (JavaCPP Presets for CUDA 10.0-7.3-1.4.3 API)</title>
<meta name="date" content="2018-10-14">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Deprecated List (JavaCPP Presets for CUDA 10.0-7.3-1.4.3 API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="overview-summary.html">Overview</a></li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li class="navBarCell1Rev">Deprecated</li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?deprecated-list.html" target="_top">Frames</a></li>
<li><a href="deprecated-list.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Deprecated API" class="title">Deprecated API</h1>
<h2 title="Contents">Contents</h2>
<ul>
<li><a href="#class">Deprecated Classes</a></li>
<li><a href="#field">Deprecated Fields</a></li>
<li><a href="#method">Deprecated Methods</a></li>
</ul>
</div>
<div class="contentContainer"><a name="class">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<table class="deprecatedSummary" border="0" cellpadding="3" cellspacing="0" summary="Deprecated Classes table, listing deprecated classes, and an explanation">
<caption><span>Deprecated Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Class and Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.nvmlEccErrorCounts_t.html" title="class in org.bytedeco.javacpp">org.bytedeco.javacpp.nvml.nvmlEccErrorCounts_t</a>
<div class="block"><span class="deprecationComment">Different GPU families can have different memory error counters
              See \ref nvmlDeviceGetMemoryErrorCounter</span></div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="field">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<table class="deprecatedSummary" border="0" cellpadding="3" cellspacing="0" summary="Deprecated Fields table, listing deprecated fields, and an explanation">
<caption><span>Deprecated Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Field and Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaDeviceBlockingSync">org.bytedeco.javacpp.cuda.cudaDeviceBlockingSync</a>
<div class="block"><span class="deprecationComment">This flag was deprecated as of CUDA 4.0 and
  replaced with ::cudaDeviceScheduleBlockingSync.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.html#nvmlClocksThrottleReasonUserDefinedClocks">org.bytedeco.javacpp.nvml.nvmlClocksThrottleReasonUserDefinedClocks</a>
<div class="block"><span class="deprecationComment">Renamed to \ref nvmlClocksThrottleReasonApplicationsClocksSetting 
             as the name describes the situation more accurately.</span></div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="method">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<table class="deprecatedSummary" border="0" cellpadding="3" cellspacing="0" summary="Deprecated Methods table, listing deprecated methods, and an explanation">
<caption><span>Deprecated Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Method and Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuCtxAttach-org.bytedeco.javacpp.cuda.CUctx_st-int-">org.bytedeco.javacpp.cuda.cuCtxAttach(cuda.CUctx_st, int)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated and should not be used.

 Increments the usage count of the context and passes back a context handle
 in \p *pctx that must be passed to ::cuCtxDetach() when the application is
 done with the context. ::cuCtxAttach() fails if there is no context current
 to the thread.

 Currently, the \p flags parameter must be 0.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuCtxDetach-org.bytedeco.javacpp.cuda.CUctx_st-">org.bytedeco.javacpp.cuda.cuCtxDetach(cuda.CUctx_st)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated and should not be used.

 Decrements the usage count of the context \p ctx, and destroys the context
 if the usage count goes to 0. The context must be a handle that was passed
 back by ::cuCtxCreate() or ::cuCtxAttach(), and must be current to the
 calling thread.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaConfigureCall-org.bytedeco.javacpp.cuda.dim3-org.bytedeco.javacpp.cuda.dim3-long-org.bytedeco.javacpp.cuda.CUstream_st-">org.bytedeco.javacpp.cuda.cudaConfigureCall(cuda.dim3, cuda.dim3, long, cuda.CUstream_st)</a>
<div class="block"><span class="deprecationComment">This function is deprecated as of CUDA 7.0

 Specifies the grid and block dimensions for the device call to be executed
 similar to the execution configuration syntax. ::cudaConfigureCall() is
 stack based. Each call pushes data on top of an execution stack. This data
 contains the dimension for the grid and thread blocks, together with any
 arguments for the call.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaLaunch-org.bytedeco.javacpp.Pointer-">org.bytedeco.javacpp.cuda.cudaLaunch(Pointer)</a>
<div class="block"><span class="deprecationComment">This function is deprecated as of CUDA 7.0

 Launches the function \p func on the device. The parameter \p func must
 be a device function symbol. The parameter specified by \p func must be
 declared as a \p __global__ function. For templated functions, pass the
 function symbol as follows: func_name<template_arg_0,...,template_arg_N>
 \ref ::cudaLaunch(const void*) "cudaLaunch()" must be preceded by a call to
 ::cudaConfigureCall() since it pops the data that was pushed by
 ::cudaConfigureCall() from the execution stack.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForDevice-double:A-">org.bytedeco.javacpp.cuda.cudaSetDoubleForDevice(double[])</a></td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForDevice-java.nio.DoubleBuffer-">org.bytedeco.javacpp.cuda.cudaSetDoubleForDevice(DoubleBuffer)</a></td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForDevice-org.bytedeco.javacpp.DoublePointer-">org.bytedeco.javacpp.cuda.cudaSetDoubleForDevice(DoublePointer)</a>
<div class="block"><span class="deprecationComment">This function is deprecated as of CUDA 7.5

 Converts the double value of \p d to an internal float representation if
 the device does not support double arithmetic. If the device does natively
 support doubles, then this function does nothing.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForHost-double:A-">org.bytedeco.javacpp.cuda.cudaSetDoubleForHost(double[])</a></td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForHost-java.nio.DoubleBuffer-">org.bytedeco.javacpp.cuda.cudaSetDoubleForHost(DoubleBuffer)</a></td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetDoubleForHost-org.bytedeco.javacpp.DoublePointer-">org.bytedeco.javacpp.cuda.cudaSetDoubleForHost(DoublePointer)</a>
<div class="block"><span class="deprecationComment">This function is deprecated as of CUDA 7.5

 Converts the double value of \p d from a potentially internal float
 representation if the device does not support double arithmetic. If the
 device does natively support doubles, then this function does nothing.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaSetupArgument-org.bytedeco.javacpp.Pointer-long-long-">org.bytedeco.javacpp.cuda.cudaSetupArgument(Pointer, long, long)</a>
<div class="block"><span class="deprecationComment">This function is deprecated as of CUDA 7.0

 Pushes \p size bytes of the argument pointed to by \p arg at \p offset
 bytes from the start of the parameter passing area, which starts at
 offset 0. The arguments are stored in the top of the execution stack.
 \ref ::cudaSetupArgument(const void*, size_t, size_t) "cudaSetupArgument()"
 must be preceded by a call to ::cudaConfigureCall().</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadExit--">org.bytedeco.javacpp.cuda.cudaThreadExit()</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is identical to the 
 non-deprecated function ::cudaDeviceReset(), which should be used
 instead.

 Explicitly destroys all cleans up all resources associated with the current
 device in the current process.  Any subsequent API call to this device will 
 reinitialize the device.  

 Note that this function will reset the device immediately.  It is the caller's
 responsibility to ensure that the device is not being accessed by any 
 other host threads from the process when this function is called.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadGetCacheConfig-int:A-">org.bytedeco.javacpp.cuda.cudaThreadGetCacheConfig(int[])</a></td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadGetCacheConfig-java.nio.IntBuffer-">org.bytedeco.javacpp.cuda.cudaThreadGetCacheConfig(IntBuffer)</a></td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadGetCacheConfig-org.bytedeco.javacpp.IntPointer-">org.bytedeco.javacpp.cuda.cudaThreadGetCacheConfig(IntPointer)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is identical to the 
 non-deprecated function ::cudaDeviceGetCacheConfig(), which should be 
 used instead.
 
 On devices where the L1 cache and shared memory use the same hardware
 resources, this returns through \p pCacheConfig the preferred cache
 configuration for the current device. This is only a preference. The
 runtime will use the requested configuration if possible, but it is free to
 choose a different configuration if required to execute functions.

 This will return a \p pCacheConfig of ::cudaFuncCachePreferNone on devices
 where the size of the L1 cache and shared memory are fixed.

 The supported cache configurations are:
 - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)
 - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache
 - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadGetLimit-org.bytedeco.javacpp.SizeTPointer-int-">org.bytedeco.javacpp.cuda.cudaThreadGetLimit(SizeTPointer, int)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is identical to the 
 non-deprecated function ::cudaDeviceGetLimit(), which should be used
 instead.

 Returns in \p *pValue the current size of \p limit.  The supported
 ::cudaLimit values are:
 - ::cudaLimitStackSize: stack size of each GPU thread;
 - ::cudaLimitPrintfFifoSize: size of the shared FIFO used by the
   ::printf() device system call.
 - ::cudaLimitMallocHeapSize: size of the heap used by the
   ::malloc() and ::free() device system calls;</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadSetCacheConfig-int-">org.bytedeco.javacpp.cuda.cudaThreadSetCacheConfig(int)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is identical to the 
 non-deprecated function ::cudaDeviceSetCacheConfig(), which should be 
 used instead.
 
 On devices where the L1 cache and shared memory use the same hardware
 resources, this sets through \p cacheConfig the preferred cache
 configuration for the current device. This is only a preference. The
 runtime will use the requested configuration if possible, but it is free to
 choose a different configuration if required to execute the function. Any
 function preference set via
 \ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) "cudaFuncSetCacheConfig (C API)"
 or
 \ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) "cudaFuncSetCacheConfig (C++ API)"
 will be preferred over this device-wide setting. Setting the device-wide
 cache configuration to ::cudaFuncCachePreferNone will cause subsequent
 kernel launches to prefer to not change the cache configuration unless
 required to launch the kernel.

 This setting does nothing on devices where the size of the L1 cache and
 shared memory are fixed.

 Launching a kernel with a different preference than the most recent
 preference setting may insert a device-side synchronization point.

 The supported cache configurations are:
 - ::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)
 - ::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache
 - ::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadSetLimit-int-long-">org.bytedeco.javacpp.cuda.cudaThreadSetLimit(int, long)</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is identical to the 
 non-deprecated function ::cudaDeviceSetLimit(), which should be used
 instead.

 Setting \p limit to \p value is a request by the application to update
 the current limit maintained by the device.  The driver is free to
 modify the requested value to meet h/w requirements (this could be
 clamping to minimum or maximum values, rounding up to nearest element
 size, etc).  The application can use ::cudaThreadGetLimit() to find out
 exactly what the limit has been set to.

 Setting each ::cudaLimit has its own specific restrictions, so each is
 discussed here.

 - ::cudaLimitStackSize controls the stack size of each GPU thread.

 - ::cudaLimitPrintfFifoSize controls the size of the shared FIFO
   used by the ::printf() device system call.
   Setting ::cudaLimitPrintfFifoSize must be performed before
   launching any kernel that uses the ::printf() device
   system call, otherwise ::cudaErrorInvalidValue will be returned.

 - ::cudaLimitMallocHeapSize controls the size of the heap used
   by the ::malloc() and ::free() device system calls.  Setting
   ::cudaLimitMallocHeapSize must be performed before launching
   any kernel that uses the ::malloc() or ::free() device system calls,
   otherwise ::cudaErrorInvalidValue will be returned.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cudaThreadSynchronize--">org.bytedeco.javacpp.cuda.cudaThreadSynchronize()</a>
<div class="block"><span class="deprecationComment">Note that this function is deprecated because its name does not 
 reflect its behavior.  Its functionality is similar to the 
 non-deprecated function ::cudaDeviceSynchronize(), which should be used
 instead.

 Blocks until the device has completed all preceding requested tasks.
 ::cudaThreadSynchronize() returns an error if one of the preceding tasks
 has failed. If the ::cudaDeviceScheduleBlockingSync flag was set for 
 this device, the host thread will block until the device has finished 
 its work.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuDeviceComputeCapability-int:A-int:A-int-">org.bytedeco.javacpp.cuda.cuDeviceComputeCapability(int[], int[], int)</a></td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuDeviceComputeCapability-java.nio.IntBuffer-java.nio.IntBuffer-int-">org.bytedeco.javacpp.cuda.cuDeviceComputeCapability(IntBuffer, IntBuffer, int)</a></td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuDeviceComputeCapability-org.bytedeco.javacpp.IntPointer-org.bytedeco.javacpp.IntPointer-int-">org.bytedeco.javacpp.cuda.cuDeviceComputeCapability(IntPointer, IntPointer, int)</a>
<div class="block"><span class="deprecationComment">This function was deprecated as of CUDA 5.0 and its functionality superceded
 by ::cuDeviceGetAttribute().

 Returns in \p *major and \p *minor the major and minor revision numbers that
 define the compute capability of the device \p dev.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuDeviceGetProperties-org.bytedeco.javacpp.cuda.CUdevprop-int-">org.bytedeco.javacpp.cuda.cuDeviceGetProperties(cuda.CUdevprop, int)</a>
<div class="block"><span class="deprecationComment">This function was deprecated as of CUDA 5.0 and replaced by ::cuDeviceGetAttribute().

 Returns in \p *prop the properties of device \p dev. The ::CUdevprop
 structure is defined as:

 <pre><code>
     typedef struct CUdevprop_st {
     int maxThreadsPerBlock;
     int maxThreadsDim[3];
     int maxGridSize[3];
     int sharedMemPerBlock;
     int totalConstantMemory;
     int SIMDWidth;
     int memPitch;
     int regsPerBlock;
     int clockRate;
     int textureAlign
  } CUdevprop;
 </code></pre>
 where:

 - ::maxThreadsPerBlock is the maximum number of threads per block;
 - ::maxThreadsDim[3] is the maximum sizes of each dimension of a block;
 - ::maxGridSize[3] is the maximum sizes of each dimension of a grid;
 - ::sharedMemPerBlock is the total amount of shared memory available per
   block in bytes;
 - ::totalConstantMemory is the total amount of constant memory available on
   the device in bytes;
 - ::SIMDWidth is the warp size;
 - ::memPitch is the maximum pitch allowed by the memory copy functions that
   involve memory regions allocated through ::cuMemAllocPitch();
 - ::regsPerBlock is the total number of registers available per block;
 - ::clockRate is the clock frequency in kilohertz;
 - ::textureAlign is the alignment requirement; texture base addresses that
   are aligned to ::textureAlign bytes do not need an offset applied to
   texture fetches.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuFuncSetBlockShape-org.bytedeco.javacpp.cuda.CUfunc_st-int-int-int-">org.bytedeco.javacpp.cuda.cuFuncSetBlockShape(cuda.CUfunc_st, int, int, int)</a>
<div class="block"><span class="deprecationComment">Specifies the \p x, \p y, and \p z dimensions of the thread blocks that are
 created when the kernel given by \p hfunc is launched.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuFuncSetSharedSize-org.bytedeco.javacpp.cuda.CUfunc_st-int-">org.bytedeco.javacpp.cuda.cuFuncSetSharedSize(cuda.CUfunc_st, int)</a>
<div class="block"><span class="deprecationComment">Sets through \p bytes the amount of dynamic shared memory that will be
 available to each thread block when the kernel given by \p hfunc is launched.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuLaunch-org.bytedeco.javacpp.cuda.CUfunc_st-">org.bytedeco.javacpp.cuda.cuLaunch(cuda.CUfunc_st)</a>
<div class="block"><span class="deprecationComment">Invokes the kernel \p f on a 1 x 1 x 1 grid of blocks. The block
 contains the number of threads specified by a previous call to
 ::cuFuncSetBlockShape().</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuLaunchGrid-org.bytedeco.javacpp.cuda.CUfunc_st-int-int-">org.bytedeco.javacpp.cuda.cuLaunchGrid(cuda.CUfunc_st, int, int)</a>
<div class="block"><span class="deprecationComment">Invokes the kernel \p f on a \p grid_width x \p grid_height grid of
 blocks. Each block contains the number of threads specified by a previous
 call to ::cuFuncSetBlockShape().</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuLaunchGridAsync-org.bytedeco.javacpp.cuda.CUfunc_st-int-int-org.bytedeco.javacpp.cuda.CUstream_st-">org.bytedeco.javacpp.cuda.cuLaunchGridAsync(cuda.CUfunc_st, int, int, cuda.CUstream_st)</a>
<div class="block"><span class="deprecationComment">Invokes the kernel \p f on a \p grid_width x \p grid_height grid of
 blocks. Each block contains the number of threads specified by a previous
 call to ::cuFuncSetBlockShape().</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuParamSetf-org.bytedeco.javacpp.cuda.CUfunc_st-int-float-">org.bytedeco.javacpp.cuda.cuParamSetf(cuda.CUfunc_st, int, float)</a>
<div class="block"><span class="deprecationComment">Sets a floating-point parameter that will be specified the next time the
 kernel corresponding to \p hfunc will be invoked. \p offset is a byte offset.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuParamSeti-org.bytedeco.javacpp.cuda.CUfunc_st-int-int-">org.bytedeco.javacpp.cuda.cuParamSeti(cuda.CUfunc_st, int, int)</a>
<div class="block"><span class="deprecationComment">Sets an integer parameter that will be specified the next time the
 kernel corresponding to \p hfunc will be invoked. \p offset is a byte offset.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuParamSetSize-org.bytedeco.javacpp.cuda.CUfunc_st-int-">org.bytedeco.javacpp.cuda.cuParamSetSize(cuda.CUfunc_st, int)</a>
<div class="block"><span class="deprecationComment">Sets through \p numbytes the total size in bytes needed by the function
 parameters of the kernel corresponding to \p hfunc.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuParamSetTexRef-org.bytedeco.javacpp.cuda.CUfunc_st-int-org.bytedeco.javacpp.cuda.CUtexref_st-">org.bytedeco.javacpp.cuda.cuParamSetTexRef(cuda.CUfunc_st, int, cuda.CUtexref_st)</a>
<div class="block"><span class="deprecationComment">Makes the CUDA array or linear memory bound to the texture reference
 \p hTexRef available to a device program as a texture. In this version of
 CUDA, the texture-reference must be obtained via ::cuModuleGetTexRef() and
 the \p texunit parameter must be set to ::CU_PARAM_TR_DEFAULT.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuParamSetv-org.bytedeco.javacpp.cuda.CUfunc_st-int-org.bytedeco.javacpp.Pointer-int-">org.bytedeco.javacpp.cuda.cuParamSetv(cuda.CUfunc_st, int, Pointer, int)</a>
<div class="block"><span class="deprecationComment">Copies an arbitrary amount of data (specified in \p numbytes) from \p ptr
 into the parameter space of the kernel corresponding to \p hfunc. \p offset
 is a byte offset.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuTexRefCreate-org.bytedeco.javacpp.cuda.CUtexref_st-">org.bytedeco.javacpp.cuda.cuTexRefCreate(cuda.CUtexref_st)</a>
<div class="block"><span class="deprecationComment">Creates a texture reference and returns its handle in \p *pTexRef. Once
 created, the application must call ::cuTexRefSetArray() or
 ::cuTexRefSetAddress() to associate the reference with allocated memory.
 Other texture reference functions are used to specify the format and
 interpretation (addressing, filtering, etc.) to be used when the memory is
 read through this texture reference.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.html#cuTexRefDestroy-org.bytedeco.javacpp.cuda.CUtexref_st-">org.bytedeco.javacpp.cuda.cuTexRefDestroy(cuda.CUtexref_st)</a>
<div class="block"><span class="deprecationComment">Destroys the texture reference specified by \p hTexRef.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.cudaPointerAttributes.html#isManaged--">org.bytedeco.javacpp.cuda.cudaPointerAttributes.isManaged()</a>
<div class="block"><span class="deprecationComment">Indicates if this pointer points to managed memory</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/cuda.cudaPointerAttributes.html#memoryType--">org.bytedeco.javacpp.cuda.cudaPointerAttributes.memoryType()</a>
<div class="block"><span class="deprecationComment">The physical location of the memory, ::cudaMemoryTypeHost or 
 ::cudaMemoryTypeDevice. Note that managed memory can return either
 ::cudaMemoryTypeDevice or ::cudaMemoryTypeHost regardless of it's
 physical location.</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.html#NVML_DOUBLE_BIT_ECC--">org.bytedeco.javacpp.nvml.NVML_DOUBLE_BIT_ECC()</a>
<div class="block"><span class="deprecationComment">Mapped to \ref NVML_MEMORY_ERROR_TYPE_UNCORRECTED</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.html#NVML_SINGLE_BIT_ECC--">org.bytedeco.javacpp.nvml.NVML_SINGLE_BIT_ECC()</a>
<div class="block"><span class="deprecationComment">Mapped to \ref NVML_MEMORY_ERROR_TYPE_CORRECTED</span></div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.html#nvmlDeviceGetDetailedEccErrors-org.bytedeco.javacpp.nvml.nvmlDevice_st-int-int-org.bytedeco.javacpp.nvml.nvmlEccErrorCounts_t-">org.bytedeco.javacpp.nvml.nvmlDeviceGetDetailedEccErrors(nvml.nvmlDevice_st, int, int, nvml.nvmlEccErrorCounts_t)</a>
<div class="block"><span class="deprecationComment">This API supports only a fixed set of ECC error locations
               On different GPU architectures different locations are supported
               See \ref nvmlDeviceGetMemoryErrorCounter

 For Fermi &tm; or newer fully supported devices.
 Only applicable to devices with ECC.
 Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts.
 Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts.
 Requires ECC Mode to be enabled.

 Detailed errors provide separate ECC counts for specific parts of the memory system.

 Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.

 See \ref nvmlMemoryErrorType_t for a description of available bit types.\n
 See \ref nvmlEccCounterType_t for a description of available counter types.\n
 See \ref nvmlEccErrorCounts_t for a description of provided detailed ECC counts.</span></div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><a href="org/bytedeco/javacpp/nvml.html#nvmlDeviceGetHandleBySerial-org.bytedeco.javacpp.BytePointer-org.bytedeco.javacpp.nvml.nvmlDevice_st-">org.bytedeco.javacpp.nvml.nvmlDeviceGetHandleBySerial(BytePointer, nvml.nvmlDevice_st)</a>
<div class="block"><span class="deprecationComment">Since more than one GPU can exist on a single board this function is deprecated in favor 
             of \ref nvmlDeviceGetHandleByUUID.
             For dual GPU boards this function will return NVML_ERROR_INVALID_ARGUMENT.

 Starting from NVML 5, this API causes NVML to initialize the target GPU
 NVML may initialize additional GPUs as it searches for the target GPU</span></div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="overview-summary.html">Overview</a></li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li class="navBarCell1Rev">Deprecated</li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?deprecated-list.html" target="_top">Frames</a></li>
<li><a href="deprecated-list.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2018. All rights reserved.</small></p>
</body>
</html>
